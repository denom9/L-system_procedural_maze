<!DOCTYPE html> 
<html> 
    <head> 
        <meta charset=utf-8> 
        <title>mazeGL</title> 
    </head> 
    <body> 
        <div id = "parameters"></div>
        <link rel="stylesheet" type="text/css" href="css/style.css">


        <!-- VERTEX SHADER -->
        <script type="x-shader/x-vertex" id="vertexShader">
            varying vec2 vUv;
            varying vec3 vecPos;
            varying vec3 vecNormal;

            void main(){
                vUv = uv;
                vecPos = (modelViewMatrix * vec4(position, 1.0)).xyz;
                vec4 modelViewPosition = modelViewMatrix * vec4(position, 1.0);
                vecNormal = (modelViewMatrix * vec4(normal, 0.0)).xyz;
                gl_Position = projectionMatrix * modelViewPosition;

                
            }
        </script>

        <!-- FRAGMENT SHADER -->
        <script type="x-shader/x-fragment" id="fragmentShader">
            precision highp float;

            varying vec2 vUv;
            varying vec3 vecPos;
            varying vec3 vecNormal;

            uniform float blockDim;
            uniform vec3 fogColor;
            uniform float fogNear;
            uniform float fogFar;

            uniform float effect;
            uniform sampler2D textureSampler;
            vec4 addedLights;

            uniform vec2 tile;

            struct PointLight {
                vec3 color;
                vec3 position; 
                float distance; 
            };
            uniform PointLight pointLights[NUM_POINT_LIGHTS];

            void main() {
                ///vec2 xy = gl_TexCoord[0].xy;
                //vec2 phase = fract(xy / Tile);
                
                addedLights = vec4(0.0,0.0,0.0,1.0);
                
                float dist;
                float radius;
                float a = 0.00;
                float b = 1.0 / (blockDim * blockDim * 0.1);
                float attenuation = 0.0;
                vec3 lightVec;
                
                radius = sqrt(1.0 / (b * blockDim));

                for(int l = 0; l < NUM_POINT_LIGHTS; l++) {
                    lightVec = vecPos - pointLights[l].position;
                    //attenuation = 1.0 / (1.0 + a * length(lightVec) + b * length(lightVec)*length(lightVec));
                    attenuation = clamp(1.0 - length(lightVec) * length(lightVec)/(blockDim * blockDim * 1.5),0.0,1.0);

                    vec3 lightDirection = normalize(lightVec);
                    addedLights.rgb += clamp(max(0.0,dot(-lightDirection,vecNormal)) * pointLights[l].color * attenuation,0.0,1.0);
                }
                
                gl_FragColor = texture2D(textureSampler,vUv) * addedLights;
                //gl_FragColor = addedLights;

                #ifdef USE_FOG
                #ifdef USE_LOGDEPTHBUF_EXT
                    float depth = gl_FragDepthEXT / gl_FragCoord.w;
                #else
                    float depth = gl_FragCoord.z / gl_FragCoord.w;
                #endif
                float fogFactor = smoothstep( fogNear, fogFar, depth );
                gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );
                #endif
            }
        </script>



        <script src="js/three.js"></script>
        <script src="js/PointerLockControls.js"></script>
        <script src="js/OBJLoader.js"></script>
        <script src="js/stats.min.js"></script>

        <script src="js/parameters.js"></script>
        <script src="js/utilities.js"></script>
        <script src="js/functions.js"></script>
        <script src="js/init.js"></script>
        <script src="js/animate.js"></script>
        <script>
            var scene, camera, renderer;
            var controls;
            var texture, material;
            var wallTexture, floorTexture, wallMaterial, floorMaterial;
            var plane;

            
            var OBJfile = httpRequest("models/torch.OBJ");
            var loader = new THREE.OBJLoader();
            var model3d = loader.parse(OBJfile);
            
            /* mappe per tenere traccia delle mesh, del labirinto generato e delle luci */
            var meshMap = {};
            var mazeMap = {};
            var lightMap = {};

            /* variabili per il movimento */
            var controlsEnabled = false;
            var moveForward = false;
            var moveBackward = false;
            var moveLeft = false;
            var moveRight = false;
            var prevTime = performance.now();
            var velocity = new THREE.Vector3();
            var wallsId;
            
            /* posizione sulla griglia prima e dopo aver raggiunto un nuovo blocco */
            var position = [0,0]; //coordinate della telecamera
            var gridPos = [0,0]; //coordinate normalizzate alla dimensione del blocco
            var newGridPos = [0,0];
            
            var wallsId = [];

            /* lista dei blocchi da generare quando si è in prossimità di essi */
            var nextBlocks = [];
            var closestBlocks = [];
            
            

            var paramBox = document.getElementById("parameters");

            var stats = new Stats();
            stats.showPanel(0); // 0: fps, 1: ms, 2: mb, 3+: custom
            document.body.appendChild( stats.dom );


            init();

            animate();
           
        </script>

    </body> 
</html>